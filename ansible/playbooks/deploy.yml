- name: deploy
  hosts: all
  gather_facts: no

  vars:
    create_dotenv: "{{ lookup('env', 'create_dotenv')|default('0') == '1' }}"
    created_env_path: ../../deploy.{{ ansible_limit }}.env

  tasks:
    - name: clone/pull repository
      git:
        repo: "{{ git_repo }}"
        version: "{{ branch }}"
        dest: "{{ project_name }}"
      # Remotes sometimes fail once, so:
      register: git_result
      retries: 1
      delay: 3
      until: git_result is succeeded
      tags: update

    - name: backup DB on code change
      include_role:
        name: backup-db
        apply:
          tags: update
      when:                               # Skip backup on:
        - git_result.changed              #   - no changes, or
        - git_result.before is not none   #   - first clone.
      tags: update

    - name: copy created .env from controller
      copy:
        src: "{{ created_env_path }}"
        dest: "{{ project_name }}/.env"
        mode: "600"
        force: no
      when: create_dotenv
      register: dotenv_copy

      failed_when: not dotenv_copy.changed
      # If the file didn't change, it already existed,
      # so stop because we're not using the file we wanted to.
      # The existing file won't be overriden because of "force: no".

    - name: delete created .env from controller
      # To avoid keeping plaintext secrets outside server
      local_action:
        module: file
        path: "{{ created_env_path }}"
        state: absent
      when: create_dotenv

    - name: set ALLOWED_HOST
      lineinfile:
        path: "{{ project_name }}/.env"
        regexp: ^ALLOWED_HOST=
        line: ALLOWED_HOST={{ server_domain }}

    - name: create nginx.env
      template:
        src: templates/nginx.env.j2
        dest: "{{ project_name }}/docker/nginx.env"
        force: yes  # Overwrites in case server_domain changes

    - name: symlink default override file to production compose
      # This is to use docker-compose CLI without "-f"
      file:
        src: "docker/docker-compose.prod.yml"
        path: "{{ project_name }}/docker-compose.override.yml"
        state: link

    - name: install apt packages
      apt:
        name:
          - python3-pip   # For ansible requirements
          - pv            # Progress for dump download
        state: present
      become: yes

    - name: install ansible requirements
      pip:
        name:
          - docker==5.0.3
          - docker-compose==1.29.2  # (yes, they use it as a library, instead of /usr/local/bin/docker-compose)
        state: present

    - name: make free space by pruning dangling images
      community.docker.docker_prune:
        images: yes
        images_filters:
          dangling: yes
      register: prune
      tags: update

    - name: show freed space
      debug:
        msg: Freed {{ prune.images_space_reclaimed | human_readable }}
      tags: update

    - name: build and start containers
      # "dcupbd"
      community.docker.docker_compose:
        state: present
        project_src: "{{ project_name }}"
        files:
          - docker-compose.yml
          - docker/docker-compose.prod.yml
        build: yes
        nocache: "{{ true if env_cache_ignore == '1' else false }}"
        remove_orphans: yes
        recreate: "{{ 'always' if env_recreate == '1' else 'smart' }}"
      vars:
        env_recreate: "{{ lookup('env', 'deploy_recreate')|default('0') }}"
        env_cache_ignore: "{{ lookup('env', 'deploy_cache_ignore')|default('0') }}"
      tags: update

    - name: run deployment checks
      command: docker-compose exec django poetry run ./manage.py check --deploy
      # Note: it's possible to fail on warning by appending: --fail-level WARNING
      args:
        chdir: "{{ project_name }}"
      changed_when: false
      failed_when: false
      register: depl_checks
      tags: update

    - name: show deployment checks
      debug:
        msg: "{{ depl_checks.stdout }}"
      failed_when: depl_checks.rc > 0
      tags: update

    - name: make a test request to https://{{ server_domain }}
      uri:
        url: https://{{ server_domain }}
        force: yes  # Ensure no cache
      tags: update

      # Some retries because nginx may not be ready yet:
      register: test_req
      until: test_req is succeeded
      retries: 10
      delay: 1
